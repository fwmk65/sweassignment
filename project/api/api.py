import sqlite3
# from flask import Flask

# app = Flask(__name__)


def QueryDatabase(path):
    """
    Function to query the database and return adjacency matrix of graph
    """
    # TODO This function will not generalise well, Add queries to find largest
    # room number and use that instead of magic numbers
    # TODO also if room number >= 10, char.isnumeric() won't pick it up. Use regexs?
    matrix = []
    db = sqlite3.connect(path)
    cursor = db.execute("SELECT roomID, adjacent FROM rooms;")
    i = 0
    for row in cursor:
        matrix.append(["-" for i in range(5)])  # TODO remove this magic number
        for char in row[1]:
            if char.isnumeric():
                matrix[i][int(char) - 1] = 1
        i += 1
    db.close()
    return matrix


def Search(start, end):
    """
    Function runs Dijkstra's algorithm on the distance matrix generated by
    Database query 
    """
    # TODO Add code to get the path rather than the list of distances
    graph = QueryDatabase("./api/toy.db")
    visited = set()
    distances = [float("inf") for i in graph]
    distances[start] = 0
    current = start
    prev = [None for i in graph]
    while end != current:
        i = float("inf")
        pos = 0
        for position, distance in enumerate(distances):
            if distance < i and position not in visited:
                i = distance
                pos = position
            elif distance == i and position not in visited:
                i = distance
                pos = position

        current = pos
        visited.add(current)
        for v, node in enumerate(graph[current]):
            if node != "-":
                new_dist = distances[current] + node
                if new_dist < distances[v]:
                    distances[v] = new_dist
                    prev[v] = current

    return distances, prev


def GeneratePath(start, end, prev):
    """
    This is a helper function for the Dijkstra's algorithm search to 
    generate the order of the path to make sure that they are 
    """
    path = []
    if prev[end] or end == start:
        while end != None:
            path.append(end)
            end = prev[end]
    path.reverse()
    return path


def helloworld():
    return "<h1>Hello, World!</h1>"


if __name__ == "__main__":
    dist, prev = Search(0, 4)
    print(GeneratePath(0, 4, prev))
    dist, prev = Search(1, 4)
    print(GeneratePath(1, 4, prev))

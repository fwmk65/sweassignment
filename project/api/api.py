import json
import re
import sqlite3
from flask import Flask
from ibm_watson import SpeechToTextV1
from ibm_cloud_sdk_core.authenticators import IAMAuthenticator


app = Flask(__name__)

# IBM Cloud Setup

# Setting Credentials
# I have stored these credentials in a file called credentials.json
# Keys are the same as the variable names
try:
    with open("credentials.json", "r") as file:
        data = json.loads(file.read())
        API_KEY = data["API_KEY"]
        STT_URL = data["STT_URL"]
except FileNotFoundError:
    API_KEY = input("Enter your API key: ")
    STT_URL = input("Enter the URL to Watson Speech To Text: ")

print(f"API key: {API_KEY} - STT_URL: {STT_URL}")

DATABASE_PATH = "./toy.db"

authenticator = IAMAuthenticator(API_KEY)
speech_to_text = SpeechToTextV1(
    authenticator=authenticator
)
speech_to_text.set_service_url(STT_URL)


def query_database(path):
    """
    Function to query the database and return adjacency matrix of graph
    """
    # TODO This function will not generalise well, Add queries to find largest
    # room number and use that instead of magic numbers
    # TODO also if room number >= 10, char.isnumeric() won't pick it up. Use regexs?
    # TODO make adjacent comma separated so you can call adjacent.split(",") later
    matrix = []
    db = sqlite3.connect(path)
    cursor = db.execute("SELECT roomID, adjacent FROM rooms;")
    i = 0
    for row in cursor:
        matrix.append(["-" for i in range(5)])  # TODO remove this magic number
        for char in row[1]:
            if char.isnumeric():
                matrix[i][int(char) - 1] = 1
        i += 1
    db.close()
    return matrix


def search(start, end):
    """
    Function runs Dijkstra's algorithm on the distance matrix generated by
    Database query 
    """
    graph = query_database(DATABASE_PATH)
    visited = set()
    distances = [float("inf") for i in graph]
    distances[start] = 0
    current = start
    prev = [None for i in graph]
    while end != current:
        i = float("inf")
        pos = 0
        for position, distance in enumerate(distances):
            if distance < i and position not in visited:
                i = distance
                pos = position
            elif distance == i and position not in visited:
                i = distance
                pos = position

        current = pos
        visited.add(current)
        for v, node in enumerate(graph[current]):
            if node != "-":
                new_dist = distances[current] + node
                if new_dist < distances[v]:
                    distances[v] = new_dist
                    prev[v] = current

    return distances, prev


def generate_path(start, end, prev):
    """
    This is a helper function for the Dijkstra's algorithm search to 
    generate the order of the path to make sure that they are 
    """
    path = []
    if prev[end] or end == start:
        while end != None:
            path.append(end)
            end = prev[end]
    path.reverse()
    return path


def audio_request():
    # TODO change this to take audio binary from request object
    with open("audio-file.flac", "rb") as audio_file:
        speech_recognition_results = speech_to_text.recognize(
            audio=audio_file,
            content_type="audio/flac",
        ).get_result()
    transcript = speech_recognition_results["results"][0]["alternatives"][0]["transcript"]
    transcript_regex = re.compile(r"from (\w|\s)+ to (\w|\s)+")
    places = transcript_regex.group()
    if places == None:
        return 400
    else:
        start = places[5:places.index(" to")]
        end = places[places.index(" to") + 3]
        return [start, end]


def home_page():
    # TODO return the home page here
    ...


if __name__ == "__main__":
    print("---Basic Dijkstra's tests---")
    dist, prev = search(0, 4)
    print(generate_path(0, 4, prev))
    dist, prev = search(1, 4)
    print(generate_path(1, 4, prev))

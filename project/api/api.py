# API for DRI Intelligent map
# NOTE: The map given as reference uses 1-based indexing to index the rooms
#       however when dealing with the adjacency matrix and generated paths,
#       0-based indexing will be used. The database for the project still
#       uses this 1-based indexing.
import json
import re
import sqlite3
from flask import Flask
from ibm_watson import SpeechToTextV1
from ibm_cloud_sdk_core.authenticators import IAMAuthenticator


app = Flask(__name__)

# IBM Cloud Setup

# Setting Credentials
# I have stored these credentials in a file called credentials.json
# Keys are the same as the variable names
try:
    with open("credentials.json", "r") as file:
        data = json.loads(file.read())
        API_KEY = data["API_KEY"]
        STT_URL = data["STT_URL"]
except FileNotFoundError:
    API_KEY = input("Enter your API key: ")
    STT_URL = input("Enter the URL to Watson Speech To Text: ")

print(f"API key: {API_KEY} - STT_URL: {STT_URL}")

DATABASE_PATH = "./hospital.db"

authenticator = IAMAuthenticator(API_KEY)
speech_to_text = SpeechToTextV1(
    authenticator=authenticator
)
speech_to_text.set_service_url(STT_URL)


def query_database(path):
    """
    Function to query the database and return adjacency matrix of graph
    Important note: The map given as a reference uses 1 based indexing,
                    however throughout this program, the distance matrix
                    and generated paths will use 0 based indexing
    """
    # TODO If you really wanted to, you can automate the finding of how many
    # rooms there are, but a hospital probably won't just get new rooms
    matrix = []
    db = sqlite3.connect(path)
    cursor = db.execute("SELECT ID, Adjacent FROM Rooms WHERE Accessible = 1;")
    i = 0
    for row in cursor:
        # 57 is the number of rooms in the hospital
        matrix.append(["-" for j in range(57)])
        rooms = row[1].split(",")
        for room in rooms:
            matrix[i][int(room) - 1] = 1
        i += 1
    db.close()
    return matrix


def search(start, end):
    """
    Function runs Dijkstra's algorithm on the distance matrix generated by
    Database query 
    """
    graph = query_database(DATABASE_PATH)
    visited = set()
    distances = [float("inf") for i in graph]
    distances[start] = 0
    current = start
    prev = [None for i in graph]
    while end != current:
        i = float("inf")
        pos = 0
        for position, distance in enumerate(distances):
            if distance < i and position not in visited:
                i = distance
                pos = position
            elif distance == i and position not in visited:
                i = distance
                pos = position

        current = pos
        visited.add(current)
        for v, node in enumerate(graph[current]):
            if node != "-":
                new_dist = distances[current] + node
                if new_dist < distances[v]:
                    distances[v] = new_dist
                    prev[v] = current

    return distances, prev


def generate_path(start, end, prev):
    """
    This is a helper function for the Dijkstra's algorithm search to 
    generate the order of the path to make sure that they are 
    """
    path = []
    if prev[end] or end == start:
        while end != None:
            path.append(end)
            end = prev[end]
    path.reverse()
    return path


def audio_request():
    # TODO change this to take audio binary from request object
    with open("audio-file.flac", "rb") as audio_file:
        speech_recognition_results = speech_to_text.recognize(
            audio=audio_file,
            content_type="audio/flac",
        ).get_result()
    transcript = speech_recognition_results["results"][0]["alternatives"][0]["transcript"]
    transcript_regex = re.compile(r"from (\w|\s)+ to (\w|\s)+")
    places = transcript_regex.group()
    if places == None:
        return 400
    else:
        start = places[5:places.index(" to")]
        end = places[places.index(" to") + 3]
        return [start, end]


def home_page():
    # TODO return the home page here
    ...


if __name__ == "__main__":
    print("---Basic Dijkstra's tests---")
    dist, prev = search(25, 55)
    print(generate_path(25, 55, prev))
    #dist, prev = search(1, 4)
    #print(generate_path(1, 4, prev))
